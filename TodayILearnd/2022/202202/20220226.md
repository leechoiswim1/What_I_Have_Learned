## 2022-02-26 To Do List

- 라쿠텐심포니 코리아 (17시)

## 2022-02-26 Done List

- 라쿠텐심포니 코리아 제출

### TIL

- 리덕스 사가
  - 액션을 모니터링하고 있다가, 특정 액션이 발생하면 이에 따라 특정 작업을 하는 방식으로 사용한다. 여기서 특정 작업이란, 특정 자바스크립트를 실행하는 것 일수도 있고, 다른 액션을 디스패치 하는 것 일수도 있고, 현재 상태를 불러오는 것 일수도 있다.
  - redux-thunk로 못하는 다양한 작업들을 처리 할 수 있다.
    - 비동기 작업을 할 때 기존 요청을 취소 처리 할 수 있다.
    - 특정 액션이 발생했을 때 이에 따라 다른 액션이 디스패치되게끔 하거나, 자바스크립트 코드를 실행 할 수 있다.
    - 웹소켓을 사용하는 경우 Channel 이라는 기능을 사용하여 더욱 효율적으로 코드를 관리 할 수 있다.
    - API 요청이 실패했을 때 재요청하는 작업을 할 수 있다.
- Generator

  - 제너레이터는 제너레이터함수의 반환

        function* myGeneratorFunction() {
        yield 1;
        yield 2;
        yield 3;
        }
        const generator = myGeneratorFunction();

            console.log(generator.next().value); // 1
            console.log(generator.next().value); // 2
            console.log(generator.next().value); // 3

  - function\* 키워드로 작성하는 함수는 제너레이터가 아닌 제너레이터함수
  - 제너레이터는 이터레이터(Iterator) 프로토콜과 이터러블(Iterable) 프로토콜을 따른다.
  - 이터러블 프로토콜은 단순히 obj[Symbol.iterator]: Function => Iterator로 표현
  - 객체는 이터레이터 심볼 키값에 이터레이터를 반환하는 메서드를 가지고 있다면 이터러블이다.
  - 이터레이터 프로토콜도 단순하다. 객체가 next라는 메서드를 가지고 있고, 그 결과로 IteratorResult 라는 객체를 반환하면 된다. 반환되는 IteratorResult는 {done: boolean, value: any} 형태의 단순한 객체다.
  - 제너레이터는 이터러블이면서 이터레이터라는 것인데, 이터러블에서 반환하는 이터레이터가 바로 자기 자신

  -제너레이터함수 - Caller와 Callee

  - 제너레이터함수는 Callee, 이를 호출하는 함수는 Caller다.
  - Caller는 Callee가 반환한 제너레이터를 가지고 로직을 수행한다.
  - Caller는 Callee의 yield 지점에서 다음 진행 여부/시점을 제어한다.
  - Redux-Saga 입장으로 보면 미들웨어는 Caller이고, 우리가 작성한 Saga는 Callee(제너레이터함수)다.

  - Redux-Saga와 제너레이터

    - Redux-Saga를 사용한다는 것은 곧 Redux-Saga 미들웨어에 우리의 Saga를 등록하고 수행시킨다는 뜻이다. 미들웨어는 Saga를 끊임없이 동작시킨다.

            // Saga의 초기화, 시작 코드에는 항상 "run"이 있다.
            middleware.run(RootSaga);

    - Saga는 제너레이터함수이고, 미들웨어는 Saga에게 yield 값을 받아서 또 다른 어떤 동작을 수행할 수 있다. Saga는 명령을 내리는 역할만 하고, 실제 어떤 직접적인 동작은 미들웨어가 처리할 수 있다는 뜻이다.

    - redux-thunk 비동기 함수 : 스스로 비동기적인 처리를 직접 수행

      function asyncIncrement() {
      return async (dispatch) => {
      await delay(1000);
      dispatch({type: 'INCREMENT'});
      };
      }

    - Saga

      function\* asyncIncrement() {
      // Saga는 아래와 같이 간단한 형태의 명령만 yield 한다.
      yield call(delay, 1000); // {CALL: {fn: delay, args: [1000]}}
      yield put({type: 'INCREMENT'}); // {PUT: {type: 'INCREMENT'}}
      }

    - call이든 put이든 모두 직접적인 처리를 하지 않는다(call, put은 이펙트 생성자(Effect creator)라 부른다). 명령을 만들어주기만 하고, 이 명령에 따른 직접적인 처리는 모두 미들웨어가 한다.
    - 그리고 Saga에서 비동기 처리가 아무리 복잡해도 대부분은 if, else, for와 같은 간단한 코드만으로 구현할 수 있다. 스코프가 복잡해지는 것도 아니다. Redux-Saga는 이런 이점을 위해 제너레이터함수를 Saga로 사용한다.

  - 이펙트

    - 미들웨어에 의해 수행되는 명령을 담고 있는 자바스크립트 객체
    - 앞서 잠깐 살펴본 call이나 put 모두 이펙트 생성자고, 생성된 이펙트는 모두 일반 자바스크립트 객체일 뿐이다. 이펙트 생성자는 항상 일반 객체를 만들기만 하고, 어느 다른 동작도 수행하지 않는다.
    - Saga는 명령을 담고 있는, 이펙트라 부르는 순수한 객체를 yield 할 것이고, 미들웨어는 이런 명령들을 해석해 처리하고, 그 결과를 다시 Saga에 돌려준다.
    - call(fn, arg1, arg2) 이펙트를 Saga에서 yield 했다면, 미들웨어는 fn(arg1, arg2);으로 수행하고 그 결과를 다시 Saga에 전달한다.
      ![SagaImg](https://image.toast.com/aaaadh/real/2018/techblog/1%282%29.png)

    - Saga는 반드시 이펙트만을 yield 해야 하는 것은 아니다. 일반적인 Promise도 yield 할 수 있고, 미들웨어는 이 역시도 훌륭히 resolve나 reject를 기다려줄 것이다. 하지만 이런 비동기 로직을 Saga 내부에서 직접 처리하면 테스트, 여러 다른 이펙트들과의 상호작용이 어렵다. thunk에서 크게 달라지는 점이 없다. 때문에 되도록 이펙트만을 yield 하는 Saga를 작성하길 추천

    - delay : 설정된 시간 이후에 resolve하는 Promise객체를 리턴한다.
      - 예시: delay(1000) → 1초 기다리기
    - put : 특정 액션을 dispatch하도록 한다.
      - 예시: put({type: 'INCREMENT]}) → INCREAMENT action을 dispatch한다.
    - takeEvery : 들어오는 모든 액션에 대해 특정 작업을 처리해 준다.
      - 예시: takeEvery(INCREASE_ASYNC, increaseSaga) → 들어오는 모든 INCREASE_ASYNC액션에 대해 increaseSaga 함수 실행
    - takeLatest : 기존에 진행 중이던 작업이 있다면 취소 처리하고 가장 마지막으로 실행된 작업만 수행한다.
      - 예시: takeLatest(DECREASE_ASYNC, decreaseSaga) → DECREASE_ASYNC액션에 대해서 기존에 진행 중이던 작업이 있다면 취소 처리하고 가장 마지막으로 실행된 작업에 대해서만 decreaseSaga함수를 실행한다.
    - call : 함수의 첫 번째 파라미터는 함수, 나머지 파라미터는 해당 함수에 넣을 인수이다.
      - 예시: call(delay, 1000) → delay(1000)함수를 call함수를 사용해서 이렇게 쓸 수도 있다.
    - call과 put의 다른 점은 put은 스토어에 인자로 들어온 action을 dispatch하고, call인 경우에는 주어진 함수를 실행하게 되는 것이다.
    - all : all함수를 사용해서 제너레이터 함수를 배열의 형태로 인자로 넣어주면, 제너레이터 함수들이 병행적으로 동시에 실행되고, 전부 resolve될때까지 기다린다. Promise.all과 비슷하다고 보면된다.
      - 예시: yield all([testSaga1(), testSaga2()]) → testSaga1()과 testSaga2()가 동시에 실행되고, 모두 resolve될 때까지 기다린다.

- 출처: https://meetup.toast.com/posts/140
- Object.entries()

  - for...in와 같은 순서로 주어진 객체 자체의 enumerable(열거가능한) 속성 [key, value] 쌍의 배열을 반환, for-in 루프가 다른점은 프로토 타입 체인의 속성도 열거한다는 점.
  - Object.entries() 에 의해 반환된 배열(array)의 순서는 객체가 정의된 방법과 관련이 없습니다. 배열 순서가 쓸 곳이 있다면, 다음과 같이 정렬을 먼저 하시는 것이 좋습니다 Object.entries(obj).sort((a, b) => b[0].localeCompare(a[0]));.

        const obj = { foo: 'bar', baz: 42 };
        console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]

        // 객체와 같은 배열
        const obj = { 0: 'a', 1: 'b', 2: 'c' };
        console.log(Object.entries(obj)); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]

        // 임의의 키 순서를 가진 객체와 같은 배열
        const anObj = { 100: 'a', 2: 'b', 7: 'c' };
        console.log(Object.entries(anObj)); // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ]

        // 객체가 아닌 인수는 객체로 강제 변환됩니다.
        console.log(Object.entries('foo')); // [ ['0', 'f'], ['1', 'o'], ['2', 'o'] ]

        // 프리미티브에는 자체 속성이 없으므로 문자열을 제외한 모든 프리미티브 유형에 대해 빈 배열을 반환합니다 (위의 예 참조).
        console.log(Object.entries(100)); // [ ]

        // 키-값을 반복
        const obj = { a: 5, b: 7, c: 9 };
        for (const [key, value] of Object.entries(obj)) {
        console.log(`${key}${value}`); // "a 5", "b 7", "c 9"
        }

        // 또는 배열 추가 사용
        Object.entries(obj).forEach(([key, value]) => {
        console.log(`${key}${value}`); // "a 5", "b 7", "c 9"
        });

- Object.keys() : 메소드는 주어진 객체의 속성 이름들을 일반적인 반복문과 동일한 순서로 순회되는 열거할 수 있는 배열로 반환

      // 단순 배열
      const arr = ['a', 'b', 'c'];
      console.log(Object.keys(arr)); // console: ['0', '1', '2']

      // 배열형 객체
      const obj = { 0: 'a', 1: 'b', 2: 'c' };
      console.log(Object.keys(obj)); // console: ['0', '1', '2']

      // 키와 순서가 무작위인 배열형 객체
      const anObj = { 100: 'a', 2: 'b', 7: 'c' };
      console.log(Object.keys(anObj)); // console: ['2', '7', '100']

      // getFoo 는 열거할 수 없는 속성입니다.
      const myObj = Object.create({}, {
        getFoo: {
          value: function () { return this.foo; }
        }
      });
      myObj.foo = 1;
      console.log(Object.keys(myObj)); // console: ['foo']

- Object.values() : 메소드는 전달된 파라미터 객체가 가지는 (열거 가능한) 속성의 값들로 이루어진 배열을 리턴합니다. 이 배열은 for...in 구문과 동일한 순서를 가집니다. (for in 반복문은 프로토타입 체인 또한 열거한다는 점에서 차이가 있습니다.)

### 🌱 회고

- saga구현시 사가가 call하지도 않았는데 바로 실행되는 문제가 있었다. 그래서 무조건 사가가 먼저 실행이 되고 그다음 동작이 작동하여 파일이 이미 불러진 상태로 로딩이 되어서 리덕스에 아무것도 남아있지 않았다. 알고보니 사가에서 export해야되는것은 호출 제네레이터함수를 관찰하고있는 관찰 제레레이터 함수를 default로 내보내야했고 그걸 루트에 등록해야했다. 우리는 호출 제네레이터 함수를 직접 등록하여 계속 뜻하지 않은 호출이 일어났던것!

        export function* fetchFileList() {
            try {
                // TODO: apis의 requestAPIs와 saga의 call에서 중복으로 타입을 지정하지 않도록 만들어보기.
                const data: FilesAPI[] = yield call(get.fileList);
                yield put(successFileList(arrayToObject(data, "key")));
            } catch (error) {
                yield put(errorFileList());
            }
            }

            export default function* watchFetch() {
            yield takeLatest(loadFileList, fetchFileList);
            }

- 위와 같이 takeLatest 이펙트를 사용하여 loadFileList액션에 대해 기존에 진행 중이던 작업이 있다면 취소 처리 가장 마지막으로 실행된 작업에 대해서 feachFileList를 실행하는것으로 해결하였다.
- (takeLatest:기존에 진행 중이던 작업이 있다면 취소 처리하고 가장 마지막으로 실행된 작업만 수행)
