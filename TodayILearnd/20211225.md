#### 2021-12-25 To Do List

[크리스마스 쉬는날]

1. 드림코딩 자바스크립트 (6-10까지 듣기 )

#### 2021-12-25 Done List

### 6. Class vs Object

####class

- class : fields(속성), methods(행동)
- data class : fields

- class => template, declare once, no data in
- object => instance of a class, created many times, data in

#### javascript class

자바스크립트는 ES6부터 class 가 도입
자바스크립트의 클래스는 기존에 있던 프로토타입이 기반된 syntactic sugar(문법적 설탕)

##### 클래스 선언

    class Person {
    constructor(name, age) {
        //fields
        this.name = name;
        this.age = age;
    }

    //methods
    speak() {
        console.log(`${this.name} : hello!`};
    }
    }

    const silver = new Person("silver", 20);
    silver.speak(); //silver : hello!

##### Getter and setters

    class User {
    constructor(firstName, lastName, age)
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }

    get age() {
        return this._age;
    }

    set age(value) {
        this._age = value < 0 ? 0 : value;
    }
    }
    const user1 = new User("Steve", "Job", 8);

getter 와 setter를 정의하게 되면
this.age 는 메모리에 올라가있는 데이터를 읽어오는 게 아니라 getter를 호출하게 된다.
그리고 this.age = age; 값을 할당할 때 바로 메모리에 값을 할당하는 것이 아니라 setter 를 호출하게 된다.
따라서 getter, setter 안의 변수는 필드와 다르게 사용해야 한다. (ex. \_age)

##### public, private fields

아직 사용하긴 이르지만 최근 추가된 기능 , 브라우저 지원 X

    class Experiment {
    publicField = 2;
    #privateField = 0;
    }

##### static properties and methods

아직 사용하긴 이르지만 최근 추가된 기능 , 브라우저 지원 X

    class Article {
    static publisher = "Dream coding";
    constructor(articleNumber) {
        this.articleNumber = articleNumber;
    }

    static printPublicsher() {
        console.log(Article.publisher);
    }
    }

데이터와 상관없이 인스턴스, 오브젝트에 상관없이 공통적으로 사용하고싶은 데이터가 필요할 때 주로 사용
오브젝트에 할당된 값이 아니라 클래스에 할당된 값

#### 상속과 다형성

##### 상속 (inheritance)

객체지향프로그래밍의 특징 중 하나로 기존에 정의되어있는 클래스의 필드와 메서드를 물려받아 새로운 클래스를 작성하는 것을 의미한다.
기존에 정의되어있는 클래스를 부모 클래스 라고 한다. 새로운 클래스는 자식 클래스.
상속은 공통된 부분을 클래스로 만들어 코드를 재활용할 수 있다는 점에서 큰 장점을 가지고 있다.

##### overloading vs overriding

오버로딩 : 매개변수를 달리하여 같은 이름의 함수를 중복하여 정의하는 것
오버라이딩 : 정의된 함수를 무시하고 같은 이름의 함수를 새롭게 정의하는 것

##### javascript의 상속

상속 관점에서 자바스크립트의 유일한 생성자는 객체뿐이다.
각각의 객체는 [[Prototype]] 이라는 은닉(private) 속성을 가진다.
프로토타입은 자신의 프로토타입이 되는 다른 객체를 가리킨다.
이를 반복하다가 결국 null을 프로토타입으로 가지는 오브젝트에서 끝난다.(종결자)
null은 더이상의 프로토타입이 없다고 정의됨며 프로토타입 체인의 종점역할을 한다. -by. MDN

##### class checking: instanceOf

자바스크립트의 모든 오브젝트와 클래스는 Javascript의 Object 을 상속한다

### 7. Object

오브젝트는 key와 value의 집합체 object = { key: value}

##### Literals and properties

    const obj1 = {}; //object literal
    const obj2 = new Object(); //object constructor syntax

    const person = { name: "kim", age: 4 };
    person.hasJob = true;
    delete person.hasJob;

자바스크립트는 동적 타입 언어기 때문에 오브젝트를 선언한 후에 프로퍼티를 삭제 및 추가 할 수 있다.

##### Computed properties (계산된 프로퍼티)

computed properties란 오브젝트에 대괄호를 사용하여 [] 프로퍼티에 접근하는 것 의미하는 것 같다.
key should be always string

    console.log(person.name); //정확하게 key를 알 때
    console.log(person["name"]); //key를 모를 때, key가 runtime에서 결정될 때
    person["hasJob"] = true;
    console.log(person["hasJob"]); //true;

##### Property value shorthand , Constructor function

    //오브젝트를 생성하는 함수
    function makePerson(name, age) {
    return {
        name,
        age
    }
    }

    //constructor function
    function Person(name, age) {
    this.name = name;
    this.age = age;
    }

##### in operator: property existence check

    console.log("name" in person); //true

##### for...in vs for ...of, for(key in obj)

        for( key in person ) {
        console.log(key); //nme, age, hasJob
        }

    //for(value of iterable)
    const arr = [1,2,3,4];
    for(v of arr){
    console.log(v); //1,2,3,4
    }

##### Cloning

    const user = {name: "kim", age: 20};
    const user2 = user;
    user2.name = "Coder";
    console.log(user); //{name: "Coder", age: 20}

    //old way
    const user3 = {};
    for (key in user) {
    user3[key] = value;
    }

    //Object.assign
    const user4 = Object.assign({}, user);

    const fruit1 = { color: "red" }
    const fruit2 = { color: "blue", size: "big" }
    const mixed = Object.assign({}, fruit1, fruit2);
    console.log(mixed); //{color: "blue", size:"big"}

### 9. Array

### 10. JSON

##### HTTP (Hypertext Transfer Protocol)

client <--- request, response ---> server

##### AJAX

- XMLHttpRequest : 브라우저에서 제공하는 오브젝트로, 간단하게 서버에게 데이터를 요청하고 받아올 수 있음
- Fetch API : 최근에 추가된 서버 통신 API, IE는 지원되지 않음

##### JSON (Javascript Object Notation)

- simplest data interchange format
- text-based
- key-value pairs
- used for serialization and transmission of data between the network the network connection
- independent programming language and platform

##### object -> serialize -> json

Object to JSON

    let json = JSON.stringify(["apple", "banana"]);
    console.log(json); //["apple", "banana"]

stringify 할 때 undefined, 함수, Symbol은 변환될 때 생략되거나 null로 변환됨
(MDN JSON/stringify)[https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify]

##### json -> deserialize -> object

JSON to Object

    let json = JSON.stringify({
    name: "kim",
    age: 10,
    jump: () => console.log("jump")
    });
    let obj = JSON.parse(json);
    console.log(obj); //{name: "kim", age: 10}

object -> json 으로 변환할 때는 함수가 포함되지 않고 데이터만 변환되기 때문에 obj에 jump 메소드가 포함되어있지 않다.

#### 2021-12-26 To Do List

1. 드림코딩 자바스크립트 (11~13 +a)
2. 트위터 클론코딩 완강
3. TIL쓰기
