## 2022-03-10 To Do List

- 코어 자바스크립트 1회독

## 2022-03-10 Done List

- 코어 자바스크립트 1회독

### TIL

- 데이터 타입

  - 변수: 변경 가능한 데이터가 담길 수 있는 공간
  - 식별자: 변수의 이름
  - 변수 선언 -> 메모리의 빈공간에 식별자 지정 -> 자동으로 undefined할당 -> 이후 변수에 기본형 데이터를 할당시 별도의 공간에 데이터를 저장 후 그 공간의 주소를 변수의 값 영역에 할당
  - 참조형 데이터 할당 : 참조형 데이터내부 프로퍼티들을 위한 변수 영역을 별도로 확보 -> 확보된 주소를 변수에 연결 -> 확보한 변수 영역에 각 프로퍼티의 식별자 저장 -> 데이터를 별도의 공간에 저장 -> 그 주소를 식별자와 매칭
  - 기본형과 참조형 데이터의 차이 : 참조형 데이터는 여러개의 프로퍼티(변수) 를 모은 그룹 , 참조형 데이터를 가변값으로 여겨야 하는 상황 ㅂ.
  - 참조형 데이터 불변값으로 사용하는 방법 (깊은복사)
    - 라이브러리 사용
    - 재귀함수
    - json.stringify
  - 없음 : undefined, null
    - undefined: 어떤 변수에 값이 존재하지 않을 경우
    - null: 사용자가 명시적으로 '없음'을 표현하기 위해 대입한 값

- 실행컨텍스트 : 실행할 코드에 제공할 환경 정보들을 모아놓은 객체

  - 전역공간에서 자동으로 생성되는 전역컨텍스트, eval(), 함수실행에 의한 컨텍스트
  - 실행컨텍스트 객체는 활성화 되는 시점에 아래 3가지 정보를 수집한다.
    - VariableEnviroment : ER과 OER로 구성, 추후 변경 없음.
    - LexicalEnviroment : ER과 OER로 구성, 함수 실행도중에 변경되는 사항이 즉시 반영
      - EnviromentRecord : 매개변수명, 변수의 식별자, 선언한 함수의 함수명 등을 수집
      - outerEnviromentReference : 바로 직전 컨텍스트의 LE 정보
    - ThisBinding : 해당 객체의 this가 무엇인지 정의
  - 호이스팅 : 코드해석을 좀 더 수월하게 하기위해 ER의 수집과정을 추상화한 개념으로 실행 컨텍스트가 관여하는 코드 집단의 최상단으로 끌어올린다고 해석, 변수 선언과 값할당이 동시에 이러진 문장은 '선언부'만 호이스팅하고 할당 과정을 원래 자리에 남아있다.
  - 함수 선언문 : 함수를 선언함 (호이스팅이 전체가 됨.)
  - 함수 표현식 : 함수를 선언하고 변수에 할당함 ( 변수만 호이스팅됨.) -> 디버깅이 용이, 사용 지향
  - 스코프 : 변수의 유효 범위 , outerEnviromentReference는 해당 함수가 선언된 위치의 LE를 참고.
    - 스코프 체이닝: 코드상에서 어떤 변수에 접근하려고 하면 현재 컨텍스트의 LE를 탐색 -> 없을 경우 OER에 담긴 LE를 탐색 , 전역 컨텍스트의 LE까지 탐색해도 해당 변수를 찾지 못하면 undefined를 반환 , 여러개의 같은 식별자가 있어도 체이닝중 처음 만나는 식별자의 값을 가져온다.
  - 전역변수 : 전역컨텍스트의 LE에 담긴 변수
  - 지역변수 : 그 밖의 함수에 의해 생성된 실행 컨텍스트의 변수
    - 안전한 코드를 위해 지역변수 지향
  - this : 실행 컨텍스트를 활성화호는 당시에 지정된 this가 저장, 지정하지 않은 경우 전역 객체

- this

  - 전역 공간에서의 this는 전역객체(브라우저에서 window, Node.js global)참조
  - 어떤 함수를 메서드로서 호출한 경우 this는 메서드 호출 주체 ( 메서드명 앞의 객체) 참조
  - 어떤 함수를 함수로서 호출한 경우 this는 전역객체를 참조, 매세드의 내부함수도 같음
  - 콜백 함수 내부에서 this는 해당 콜백 함수의 제어권을 넘겨받은 함수가 정의한 바에 따름, 정의하지않은 경우 전역객체
  - 생성자 함수에서의 this는 생성될 인스턴스 참조

  - 명시적 this binding
    - call,aplly 메서드는 this를 명시적으로 지정하면서 함수 또는 메서드를 호출
    - bind 메서드는 this 및 함수에 넘길 인수를 일부 지정해서 새로운 함수를 만든다
    - 요소를 순회하면서 콜백함수를 반복 호출하는 내용의 일부 메서드는 별도의 인자로 this를 받기도 한다.
      - ex) Array.prototype.forEach(callback[, thisArg])

-콜백함수 : 다른 코드에 인자로 넘겨줌으로써 그 제어권도 함께 위임한 함수

- 제어권을 넘겨받은 코드는 다음과 같은 제어권을 가짐
  - 콜백 함수를 호출하는 시점을 스스로 판단해서 실행
  - 콜백 함수를 호출 할 때 인자로 넘겨줄 값들 및 그 순서가 정해져있음
  - 콜백 함수의 this가 무엇을 바라도로록 할지가 정해져 있는 경우도 있음. 정하지 않은 경우에는 전역객체를 바라봄. 사용자 임의로 this를 바꾸고 싶을 경우 bind메서드를 활용
- 어떤 함수에 인자로 메서드를 전달해도 함수로 실행
- 비동기 제어를 위해 콜백함수를 사용하다보면 콜백 지옥에 빠지기 쉬움
- es6이후 promise,Generator,async/await을 사용해 비동기제어를 가능

- 클로저

  - 어떤 함수에서 선언한 변수를 참조하는 내부 함수를 외부로 전달할 경우, 함수의 실행 컨텍스트가 종료된 후에도 해당 변수가 사라지지 않는 현상
  - 선언될 당시의 LE와의 상호관계
  - 내부 함수를 외부로 전달하는 방법에는 함수를 return하는 경우뿐 아니라 콜백으로 전달하는 경우도 포함
  - 클로저는 그본질이 메모리를 계속 차지하는 개념이므로 더는 사용하지 않게 된 클로저에 대해서는 메모리를 차지않도록 관리해줘야한다 ( 더 이상 사용하지 않을경우 null,undefined를 넣어 Gc의 대상이 되게 만듬)
  - 클로저 활용 사례
    - 콜백 함수 내부에서 외부 데이터를 사용하고자할때
    - 접근권한제어(정보 은닉)
      - 함수에서 지역변수 및 내부함수 등을 생성
      - 외부에 접근권한을 주고자 하는 대상들로 구성된 참조형 데이터(대상이 여럿일경우 객체 또는 배열, 하나일경우 함수)를 return 함.
    - 부분적용함수 : n개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억, 나중에 (n-m) 개의 인자를 넘기면 비로소 원래 함수의 실행결과를 얻을 수 있께 하는 함수
      - 디바운스(eventName,func,wait,timeoutId)
  - 커링 함수: 여러 개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인 형태로 구성
    - 한번에 하나의 인자만 전달하는 것을 원칙
    - 중간 과정상의 함수를 실행한 결과는 그다음 인자를 받기위해 대기, 마지막 인자가 전달되기 전까지는 원본 함수가 실행 되지 않음( 부분 적용 함수는 여러개의 인자를 전달, 실행결과를 재실행할때 원본 함수가 무조건 실행)
    - 부분 적용 함수와 달리 커링함수는 필요한 상황에 직접 만들어쓰기 용이, 필요한 인자 개수만큼 함수를 만들어 계속 리턴해주다가 마지막에 조합해서 리턴함. 인자가 많아질수록 가독성이 떨어짐
    - 화살표 함수로 구현하면 가독성이 좋아짐
    - 화살표 순서에 따라 함수에 값을 차례로 넘겨주면 마지막에 func가 호출 될거라는 흐름이 파악
    - 각 단계에서 받은 인자들을 모두 마지막 단계에서 참조할 것이므로 Gc 되지않고 메모리에 쌓이다가 마지막 호출로 실행 컨텍스트가 종료되면 GC의 수거 대상이 된다.
    - 커링함수가 유용한 경우
      - 지연 실행 lazy execution : 당장 필요한 정보만 받아서 전달, 또 필요한 정보가 들어오면 전달하는 식으로 결국 마지막 인자가 넘어갈때까지 함수의 실행을 미룬다. 원하는 시점까지 지연시켰다가 실행 (http요청시)
      - flux 아키텍처의 구현체 중 하나인 redux 미들웨어 ( store,next,action순서로 인자를 받음 이중 store와 next 프로젝트내에서 한번 생성된 이후로 바뀌지 않음, action의 경우 매번 달라짐, store와 next값이 결정되면 내부에서 logger또는 thunk에 store,next를 미리 넘겨서 반환된 함수를 저장, 이후 action만 받아서 처리)

- 프로토타입

  - 클래스 기반 언어에서는 '상속'을 사용하지만 프로토타입 기반 언어에서는 어떤객체를 '원형'으로 삼고 이를 복제(참조)함으로써 상속과 비슷한 효과를 얻음
  - 어떤 생성자함수(constuctor)를 new연산자와 함께 호출
  - Constructor에서 정의된 내용을 바탕으로 새로운 인스턴스instance가 생성
  - 이때 instance에는 **proto**라는 프로퍼티가 자동으로 부여, **proto**는 생략 가능한 프로퍼티, 생성자 함수의 prototype프로퍼티를 참조
  - 인스턴스는 constructor의 prototype이라는 프로퍼티를 마치 자신의 메서드인것처럼 호출할 수 있음.

  - constructor.prototype에는 constructor라는 프로퍼티 이는 생성자 함수 자기 자신, 인스턴스의 생성자 함수를 알 수 있음
  - 최종적으로는 Obejct.prototype
  - 프로토타입 체이닝: **proto**안에 **proto**를 찾아가는 것, 이를 통해 각 프로토타입 메서드를 사용할 수 있다. 원하는 값을 찾으면 검색을 중단(스코프체이닝과 같음)
  - Object.prototype: 모든 데이터 타입에서 사용할 수 있는 범용적인 메서드만이 존재, 객체 전용 메서드는 Object 생성자 함수에 스태틱하게 담겨있다.
  - 프로토타입 체인은 반든시 2단계로 이루어지는것이아니라 무한대로 단계를 생성할수있다.

  - 동일한 대상을 가르킴

    - instance.**proto**보다는 Object.getPrototypeOf()/Object.creat() 지향
    - [Constuctor]
    - [instance].**proto**.constructor
    - [instance].constructor
    - Object.getPrototypeOf([instance]).constructor
    - [Constructor].prototype.constructor

  - 프로토타입 체인
    - 메서드 오버라이드 : 인스턴스가 prototype에 정의된 프로퍼티,메서드와 같은 이름의 프로퍼티나 메서드를 가지고있는 경우 오버라이드된다. 우회해서 다른 프로퍼티에 접근가능
  - Object.create(null)은 **proto**가 없는 객체 생성 : 내장 메서드 및 프로퍼티들이 제거, 기본기능에 제약이 생긴대신 객체 자체의 무게가 가벼워져서 성능상 이점이있다.

- 클래스 : 자바스크립트는 프로토타입 기반 언어여서 '상속'개념이 존재 하지 않음.

### 🌱 회고

- 코어 자바스크립트 통해 한번씩 주요 개념들을 훑었고 머리 속으로 자바스크립트에 대해 정리하는 시간을 가졌다.
- 현재 서버의 인스턴스 만료 문제로 디스캐치 리팩토링이 중단됐다. 백엔드에서 새로운 서버로의 이전을 처리중이며 이번주내로 제발... 리팩을 다시 시작했으면 좋겠다.

## 2022-03-11 To Do List

- 면접 준비 (프로젝트, 인성 관련 )
- 면접 후 피드백 정리
