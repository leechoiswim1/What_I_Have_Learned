#### 2021-12-28 To Do List

1. 드림코딩 자바스크립트 (11~13 +a)
2. 포트폴리오 점검
3. 포트폴리오 클론코딩 결제

#### 2021-12-28 Done List

### 11.Callback

//JavaScript is synchronous.
//Execute the code block in order after hoisting.
//hoisting: var,function declaration ( 자동적으로 가장 상단으로 올라감. )
console.log('1');
setTimeout(()=>console.log('2'), 1000);
console.log('3');

//Synchronous callback

    function printImmediately(print){
    print();
    }
    printImmediately(()=> console.log('hello'));

//Asychronous callback
function printWithDelay(print,timeout);
setTimeout(print,timeout);
}

    printWithDelay(()=>console.log('async callback'),2000);

//Callback Hell Example

    class UserStorage{
    loginUser(id,password,onSuccess,onError){
        setTimeout(()=?{
            if(
                (id==="ellie" && password==="dream")||
                (id==="coder" && password==="academy")
            ) {
                onSuccess(id);
            } else {
                onError(new Error('not found'));
            }
        },2000)
    }
    getRoles(user,onSuccess,onError){
        setTimeoust(()=>{
            if(user==="ellie"){
                onSuccess({name:"ellie",role:"admin"});
            }else{
                onError(new Error('no acess'));
            }
        },1000)
        }
    }
    const useStorage= new UserStorage();
    const id =prompt('enter your id');
    const password =propmt('enter you password');

    userStorage.loginUser(
        id,
        password,
        user=>{
            userStorage.getRoles(
                user,
                userWithRole => {
                    alert(`Hello ${userWirhRole.name}, you have a ${userWirhRole.role} role`);
                    },
                error => {
                    console.log(error);
                    }
                );
            },
        error => {
            console.log(error);
        }
    );

=>가독성이 떨어지고 에러가 날경우 에러가 어디에서 났는지 찾기가 힘들다.

### 12.Promise is a JavaScript object for asynchronous operation.

// State : peding -> fuifilled or rejected
// Producer / Consumer 차이점

1. Producer
   //when new Promise is created, the executor runs automatically.
   -> 이 경우는 프로미스가 생성되면 바로 executor가 실행된다. 클릭이벤트로 프로미스 처리하고싶으면 다르게 처리해야한다.
   const promise = new Promise((resolve,reject)=>{
   //doing some heavy work (network, read files)
   console.log('doing something...')
   setTimeout(()=>{
   resolve('ellie');
   <!-- reject(new Error('no network')) -->

   },2000);
   });

2. Consumers: then, catch, finally
   promise
   .then(value=>{
   console.log(value);
   })
   .catch(error=>{
   console.log(error);
   })
   //성공 실패와 상관없이 어떤것을 마지막으로 실행하고싶을때 finally를 쓴다.
   .finally(()=>{
   console.log('finally`);
   });

3. Promise chaining
   const fetchNumber = new Promise((resolve,reject) => {
   setTimeout(()=>resolve(1),1000);
   });
   fetchNumber
   .then(num => num*2)
   .then(num => num*3)
   .then (num-=>{
   return new Promise((resolve,reject)=>{
   setTimeout(()=>resolve(num-1),1000);
   });
   })
   .then(num=>console.log(num));

4.Error Handling

    const getHen=()=>
        new Promise ((resolve,reject)=>{
            setTimeout(()=>resolve('🐓'),1000);
        });
    const getEgg=hen=>
        new Promise ((resolve,reject)=>{
            setTimeout(()=>resolve(`${hen}=>🥚`),1000);
        });
    const cook=egg=>
        new Promise ((resolve,reject)=>{
            setTimeout(()=>resolve(`${egg}=>🍳`),1000);
        });
    getHen()//
        .then(hen=>getEgg(hen))
        .then(egg=>cook(egg))
        .then(meal=>console.log(meal));
        ===
         //받아오는 value를 바로 다음함수에 전달하는 경우 value 생략 가능.
        .then(getEgg)
        //에러 핸들링 : 위에서 발생한 에러를 잡고싶으면 밑에 catch를 넣어서 에러가 발생했을때 대처할수있는 데이터를 넣어줌으로써 에러를 핸들링한다.
        .catch(error=>{
            return '🍞';
        });
        .then(cook)
        .then(console.log)
        .catch(console.log);
        //마지막에 에러가 나오게 할수도있으나 에러 핸들링이 되지않아서 마지막까지 함수가 완성되지 않는다.

###### Callback to Promise

    class UserStorage{
        loginUser(id,password){
            return new Promise((resolve,reject)=>{
                setTimeout(()=>{
                    if(
                        (id==="ellie" && password==="dream")||
                        (id==="coder" && password==="academy")
                    ) {
                        resolve('id')
                    } else {
                        reject(new Error('not found'));
                    }
                },2000)
            }
        }
        getRoles(user){
            return new Promise((resolve,reject)=>{
                setTimeout(()=>{
                    if(user==="ellie"){
                        resolve({name:"ellie",role:"admin"});
                    }else{
                        reject(new Error('no acess'));
                    }
                },1000)
            }
        }
    }
    const useStorage= new UserStorage();
    const id =prompt('enter your id');
    const password =propmt('enter you password');

    userStorage//
        .loginUser(id,password)
        .then(userStorage.getRoles)
        .then(user->alert(`Hello ${user.name}, you have a ${user.role} role`))
        .catch(console.log);

### 13. async & await

//syntactic sugar, clear style of using promise.

1.async

    //동기처리
    function fetchUser(){
        //do network request in 10 secs...
        // 동기처리하기때문에 10초동안 이코드에서 아무것도 안하고 머뭄 => 프로미스로 비동기 처리해줌.
        return 'ellie';
    }
    const user = fetchUser();
    console.log(user);

    //promise추가 (비동기처리)
    function fetchUser(){
        return new Promise((resolve,reject)=>{
            resolve('ellie')
        })
    }
    const user = fetchUser();
    user.then(console.log);
    console.log(user);

    //async & await추가
    async function fetchUser(){
           return 'ellie';
        }
    }
    const user = fetchUser();
    user.then(console.log);
    console.log(user);

2.await✨

    function delay(ms){
        return new Promise(resolve=>setTimeout(resolve,ms));
    }

    async function getApple(){
        await delay(1000);
        return 'apple';
    }

    async function getBanana(){
        await delay(1000);
        return 'banana';
    }
    //콜백지옥처럼 프로미스 지옥이 된다.
    function pickFruits(){
        return getApple().then(apple=>{
            return getBanana().then(banana=>`${apple}+${banana}`);
        });
    }

    async function pickFruits(){
        try{
        //동기 처리 함(쓸데없는 처리)
        const apple =await getApple();
        const banana=await getBanana();
        return `${apple}+${banana}`
    }catch{
        (error)=>console.log(error)
    }
    pickFruits().then(console.log)

    async function pickFruits(){
        try{
        //병렬적으로 실행할수있는경우 프로미스를 바로 실행시켜 비동기처리함
        const applePromise=getApple();
        const bananaPromise=getBanana();
        const apple =await applePromise;
        const banana=await bananaPromise;
        return `${apple}+${banana}`
    }catch{
        (error)=>console.log(error)
    }
    pickFruits().then(console.log)

    //병렬적으로 실행할수있는경우 프로미스를 바로 실행시켜 비동기처리함 -> 이경우 promise에 있는 allAPI를 통해 더 간결하게 처리할수있다.
    async function pickFruits(){
    function pickFruits() {
        retrun Promise.all([getApple(),getBanana()])
        .then(fruits=>fruits.join('+'));
    }

    pickAllFruits().then(console.log);

    //Promise race Api = Promise에 전달한 함수중 가장 먼저 리턴한 함수의 값이 리턴된다.
    fuction pickOnlyOne(){
        return Promise.race([getApple(),getBanana()]);
    }

###### promise to async & await

    const useStorage= new UserStorage();
    const id =prompt('enter your id');
    const password =propmt('enter you password');

    async function checkUser(){
        try{
            const id=await serStorage.loginUser(id,password);
            const user=await userStorage.getRoles(id);
            return alert(`Hello ${user.name}, you have a ${user.role} role`)
            }
        catch(error){
            console.log(error)
        }
    }
    checkUser();

#### 2021-12-29 To Do List
