#### 2022-01-07 To Do List

- 코어 자바스크립트 (2강~4강)
- 코딩애플 자바스크립트 완강 및 정리
- 딥다이브 일주일 정리
- 면접리스트 답변 채우기

#### 2022-01-07 Done List

- 코어 자바스크립트 (2강~3강)[⭕]
- 코딩애플 자바스크립트 완강 및 정리 [❌]
- 딥다이브 일주일 정리 [❌]
- 면접리스트 답변 채우기 [❌]

#### TIL

오늘은 오전에 좀 쉬고 오후에 코어자바스크립트를 좀 봤다.
봐도봐도 헷갈리는걸.... ㅎ\_ㅎ ;

오늘 웹소켓이 연결됐다!! 서버 시간을 조절하는일이 남았지만 그래도 웹소켓이 해결되서 너무 기쁘다...
그저께 우연히 로컬에서는 웹소켓이 된다는걸 알았고 백엔드에 배포 요청을 했다. 그러나 백엔드 배포하신분이 바빠서 하루동안 연락이 없으시다가 오늘오전에 고치시고있다는 연락을 받았다.
우리는 계속 똑같은 요청에 배포 사이트만 다르게 적용한 상태였다.
서버에서도 같은 코드라며 배포만하면 웹소켓 오류가 나는 상태를 이해할수없다는 입장이였다.
답답한 마음에 직접 검색을 했다. 그리고 비슷한 상태의 글을 보면 백엔드에 공유했고 그러다보니 setAllowedOrigin의 문제가 아닐까하는 추측이 생겨났다.
그래서 벡엔드분에게 setAllowedOrigin의 수정을 요청드렸고, 반신반의 하며 수정하셨다 그러나 적용되지않아 실망하고있었는데
setAllowedOrigins("_")
setAllowedOrigins("https://localhost:3000")
setAllowedOrigins("https://discatch.site")
를 입력했더니 웹소켓이 연결됐다.
setAllowedOrigins("_")
setAllowedOrigins("https://localhost:3000")

#### 코어자바스크립트 2강 (컨텍스트)

실행컨텍스트(execution Context:문맥,맥락)
실행할 코드에 제공할 환경 정보를 모아놓은 객체
자바스크립트의 동적 언어로서의 성경을 가장 잘 파악할수 있는 개념
동일한 환경에 있는 코드등을 실행할때, 필요한 환경 정보들을 모아 컨텍스트를 구성
콜스택에 쌓고 가장 위에 있는 컨텍스트와 관련있는 코드를 실행
전체 코드의 환경과 순서를 보장한다.
동일환경-하나의 실행 컨텍스트를 구성하고있는 방법: 전역공간, eval(), 함수 등
객체활성시점: variable enviroment, lexical enviroment, this biding

virable enviroment
초기에 담기는 내용은 lexical enviroment와 같다.
그러나 varibale enviroment는 최초 실행시 스냅샷을 유지한다.
실행컨텍스트 생성-> variable enviroment정보구성 -> variable를 복사하여 lexical enviroment 만듬 -> 주로 활용한다.
enviroment record
outer enviroment reference 로 구성된다.

lexical enviroment
ex)현재 컨텍스트 내부에는 a,b,c와같은 식별자가 있고 그외부정보는 d를 참조하도록 구성됨
초기에 담기는 내용은 virable enviroment 같으나 함수 실행 도중 변경되는 사항을 즉시반영

enviromnet record
현재 컨텍스트와 관련된 코드의 식별자 정보들(매개변수이름, 함수선언, 변수명...) 이 저장
컨텍스트를 구성하는 함수의 지정된 매개변수 식별과 선언한 함수가 있는 경우 함수 그자체, var로 선언된 변수의 식별자들 순서대로 수집

전역 실행컨텍스트경우 enviroment record는 전역객체를 활용한다. (window, global 객체)

호이스팅 :enviroment record 단계에서 식별자들을 최상단으로 끌어올림 (변수정보를 수집하는 과정)

함수선언문/ 함수표현식
-> 함수 선언문의 경우 전체 호이스팅, 표현식은 식별자(변수선언부)만 호이스팅 (언디파인이다)
함수선언문:반등시 함수의 명이 정의 되어야 한다.
function add(){};
함수표현식: 기명함수와 무기명 함수가있다.
무기명 함수의 경우 식별자 이름이 함수이름으로 선언된다.

기명함수표현식: let add=function plus(){}; 외부에서 함수명(plus)로 호출이 불가하다
무기명함수표현식 let add =function (){};

상대적으로 함수 표현식이 안전하다.
전역변수의 최소화가 좋다.

스코프, 스코프체인, outEnvriomentReference

스코프: 식별자에 대한 유효범위
var스코프: 함수 스코프
let, const 스코프: {} 블록 스코프

스코프체인: 식별자의 유효범위를 안에서부터 바깥으로 차례대로 검색해 나가는것
lexical enviroment의 outer EnviromentReference ( 바로 직전의 컨텍스트의 lexical enviroment 참조)
현재 호출된 함수가 선언될 당시의 lexical 환경을 참조한다.
연결 리스트(linked list)의 형태이다
무조건 스코프 체인상에서 가장 먼저 발견된 식별자에만 접근이 가능하다.

변수은닉화(variavle shadowing)
같은 스코프에서 a변수선언을 하면 전역공간의a는 사용이 불가하다.

this biding
this로 지정된 객체 저장
this가 지정되지 않은경우 this는 전역객체다(window)

#### 코어자바스크립트 3강 this

this:실행 컨텍스트가 생성될때 함께 결정된다
this는 함수가 호출될때 결정된다
함수를 어떤 방식으로 호출하냐에따라 값이 달라진다.

전역공간에서의 this: 전역객체(window, global)

전역변수 선언시 전역객체의 프로퍼티로 할당한다
변수는 특정객체(lexical enviroment)의 프로퍼티이다.
그러나, var로 선언한 전역변수 전역객체의 프로퍼티는 호이스팅 여부,configuation여부 ( 변경/삭제 가능성)에 차이가 있다.
var로 선언하면 delete하지 못한다.

함수 vs 메서드 (독립성의 차이)
함수는 독립적, 메서드는 객체에 관한 동작을 수행하기때문에 비독립적이다.
함수로서의 호출, 메서드로서의 호출이 다르다
메서드로서의 호출은 앞에 .객체 or [객체] 가 붙는다.

매세드 내부에서의 this (호출한 주체정보)
함수로서 호출할때 그 함수 내부에서의 this ->window(버그다)

함수로서의 호출(window)
메서드로서의 호출(호출주체 객체)

로 구분한다.

메서드 내부함수에서 this 우회법
es5전
var self=this(상위 스코프 this를 저장함.) 선언 후 함수 내부에서 self를 호출하여 this를 간접적으로 사용한다

es6후
this 바인딩 당하지 않는함수 : 화살표함수
실행컨텍스트과정에서 this바인딩과정 자체가 없다.
상위스코프 this를 사용가능하다.

콜백함수
함수의 a제어권을 b에게 넘겨주는 경우 함수a를 콜백함수라고 부른다. 함수 a는 b의 내부조직에 따라 실행된다.
this도 함수 b 내부조직 규칙에 따라 결정되고 콜백함수도 함수이기때문에 this=전역객체이다. 그러나 제어권을 받은 함수에서 콜백함수에 별도로 this가 될 대상을 지정한 경우에는 그 대상을 참조한다.

생성자 함수 내부에서의 this
클래스: 구체적인 인스턴스를 만들기위한 틀인 생성자
인스턴스: 클래스를 통해 만든 객체

생성자 함수로서 호출 this는 인스턴스 자기 자신이다.

new 생성자 함수를 호출하면 생성자의 prototype 프로퍼티를 참조하는 **proto** 라는 프로퍼티가 있는 객체 인스턴스를 만들고 미리준비된 공통 속성, 개성을 부여한다

명시적this 바인딩(별도의 대상 바인딩)

call메서드
호출의 주체인 함수, 즉시실행한다.
function prototype.call(thisArg[, arg][, arg2][, ...])
첫번째인자 -> this (임의 객체 this 지정이 가능한다 )
그 이후에는 매개변수를 전달한다

apply 메서드
call과 유사하지만 두번째 인자를 배열로 받아 그 배열의 요소들을 호출 함수의 매개변수를 지정
function prototype.apply(thisArg[, argArray])
`
call/apply 메서드의 활용

유사배열객체에 배열 메서드를 적용

#### 2022-01-08 To Do List
