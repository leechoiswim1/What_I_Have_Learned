#### deepdive (60p-90p)

### [6장 데이터 타입]

- 데이터타입 ( 줄여서 타입 ): 값의 종류
- js의 모든값은 데이터 타입을 가짐.
- 7개의 데이터 타입 ( 원시타입 / 객체타입 )
  원시타입: number, string, boolean, undefined, null, symbol
  객체타입: object, function, array...

- number: 산술연산을 위해 생성
- string: 텍스트를 화면에 출력하기 위해 생성

##### number

- 모든 수를 실수로 처리, 정수만 표현하기위한 데이터타입이 별도로 존재하지 않음.
- 배정밀도 64비트 부동소수점 형식의 2진수로 저장
- 값을 참조하면 10진수로 해석 ( 해석하기위해 다른 타입을 제공하지 않는다.)
- 실수로 처리하기때문제 정수로 표현된 값끼리 연산해도 실수가 나올수 있다.
- +infinity , -infinity, NaN(Not a number)

##### string

- utf-16
- 작은따옴표, 큰따옴표, 백틱으로 감싸야한다. 그렇지 않으면 키워드나, 식별자 같은 토큰으로 인식
- c: 문자열타입 제공 x 문자의 배열로 문자열 표시
- 자바: 문자열을 객체로 표현ㅛ
- js: 문자열 원시타입, immutable value (생성한 후 변경할 수 없다.)

##### template literal

1. multi-line string

- 일발 문자열 : 개행 불가. 공백표시시, 이스케이프 시퀀스 사용 (\)
- 템플릿 리터럴 : 개행 가능.

2. expression intherpolation

- 문자열 연산자 + 사용하여 연결
- 템플릿 리터럴 + 표현식 삽입(expression interpolation) : 가독성이 좋고 간편하게 문자열 조합 , ${} 표현식 감싸서 삽입, 문자열이 아니어도 문자열로 타입 변환.

3. tagged template

##### boolean

##### undefined

- 변수 선언 후 암묵적으로 undefined로 초기화 됨
- 변수 선언 -> 메모리 공간 확보 (garbage value) =>엔진이 undefined로 초기화
- 변수 참조시 undefined라면 초기화되지 않은 변수.

##### null

- 변수에 값이 없다는 것을 의도적으로 명시 (의도적 부재 intentional absence)할때 사용
- null 할당: 변수가 이전에 참조하던 값을 더이상 참조하지 않겠다, 참조를 명시적으로 제거
- 엔진은 가비지 콜렉션을 수행

##### symbol

- 변경 불가능한 원시타입의 값
- 다른 값과 중복되지 않는 유일무이한 값
- 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 위해 사용
- symbol함수를 호출해서 생성
- 심벌값은 외부에 노출되지 않으며 다른값과 절대 중복되지 않는 유일무이한 값이다.

##### object

- 자바스크립트를 이루고 있는 거의 모든것이 객체

##### 데이터 타입의 필요성

- 값은 메모리에 저장하고 참조할 수 있도록 확보해야 할 메모리의 크기를 결정하여 값을 저장한다.
- 변수에 할당되는 값은 '데이터 타입'에 따라 확보해야 할 메모리 공간의 크기가 결정.
- 컴파일러 또는 인터프리터는 심벌테이블이라고 부르는 자료구조를 통해 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리
- 즉, 메모리를 적절하게 관리하기 위해 데이터 타입이 필요하다. 심벌테이블을 통해 데이터의 타입을 결정하고 메모리에 확보할 크기를 결정하여 값을 저장.

##### 동적타이핑

- 정적타입 언어 : c/자바 , 데이터 타입 사전 선언, 명시적 타입 선언 (explicit type declaration), 변수의 타입 변경 불가, 타입에 맞는 값만 할당 , 컴파일 시점에 타입체크, 타입의 일관성 강제, 런타임에 발생하는 에러를 줄임.
- 동적타입 언어 : 자바스크립트, var,let,const로 변수 선언, 어떤 데이터 값이라도 자유롭게 할당할수있음.
- 동적타이핑, 동적타입언어 자바스크립트의 변수는 선언이 아닌 '할당'에 의해 타입이 결정
- 변수는 타입을 갖지 않는다. 값은 타입을 갖는다.

##### 동적 타입 언어와 변수

- 동적타입의 구조적 단점: 유연성(flexibility) 은 높지만 신뢰성(reliability)은 떨어진다.

1. 변수 값은 언제든지 변경 될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있다
2. 값의 변경에 의해 타입도 언제든지 변경될 수 있다.
3. 변수는 값을 확인하기 전에는 타입을 확신할 수 없다.
4. 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다.

- 변수 사용시 주의사항

1. 변수는 꼭 필요한 경우에 한해 제한적으로 사용
2. 변수의 유효범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제해야함.
3. 전역변수는 최대한 사용하지 않도록한다, 전역변수는 프로그램의 복잡성을 증가시키고 처리 흐름을 추적하기 어렵게 만들고 오류가 발생할 경우 오류의 원인을 특정하기 어렵게 만든다.
4. 변수보다는 상수를 사용해 값의 변경을 억제한다.
5. 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.(직관적네이밍)

### [7장 연산자 operator]

- 연산자: 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.
- 피연산자: 연산의 대상자, 값으로 평가될 수 있는 표현식이여야함.
- 피연산자(값, 명사) , 연산자(새로운값을 만든다, 동사)

##### 산술 연산자 (arithmetic operator)

- 피연산자를 대상으로 수학적 계싼을 수행해 새로운 숫자값을 만듬. 산술연산이 불가능한 경우 NaN을 반환

1. 이항 산술 연산자 
- 2개의 피연산자를 산술 연산하여 숫자 값을 만든다.
- 피연산자의 값을 변경하는 '부수효과(side effect)'가 없다.
- 피연산자의 값이 바뀌는 경우는 없고 언제나 새로운 값을 만든다.

2. 단항 산술 연산자
- 1개의 피연산자를 산술 연산하여 숫자 값을 만든다.
- 증가/감소(++/--) 연산자는 부수효과가 있다. ( 피연산자의 값을 변경하는 암묵적 할당이 이뤄진다.)
- 증가/감소 연산자는 위치에 의미가 있다. 
- 전위증가/감소연산자 ( 피연산자의 값을 증가/감소 시킨후 다른 연산을 수행)
- 후위증가/감소연산자 ( 피연산자의 다른 연산을 수행한 후 값을 증가/감소 시킴)
- '+'단항 연산자: 피연사자에 어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다.
- '-'단항 연산자: 피연산자의 부호를 반전한 값을 반환한다. 
- 숫자타입이 아닌 피연산자에 +- 단항 연산자를 사용하면 피연산자를 숫자타입으로 변환하여 반환한다. ( 변환된 값을 반환하는것이지 피연산자를 변경하진 않는다. 부수효과 없음)

3. 문자열 연결 연산자
- '+'연산자는 피연산자 중 하나 시아이 문자열인경우 문자열 연결 연산자로 동작한다. 그외는 산술 연산자.

        1 + true; //2 
        //true는 1로 타입변환 된다.

- 암묵적 타입 변환(implicit coercion), 타입강제변환(type coercion)


##### 할당 연산자(assignment operator) 

- 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 
- 좌항의 변수에 값을 할당함으로 '부수효과'가 있다.
- 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가됨 -> 변수에 동일한 값을 연쇄 할당할 수 있다.

##### 비교 연산자(comparison operator) 

- 좌항, 우항의 피연산자를 비교한 다음 그결과를 boolean값으로 반환.
- 제어문의 조건식에서 주로 사용 (if문, for문) 

1. 동등(loose equality)/일치(strict equality) 비교 연산자
- 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 boolean값을 반환. 
- but, 비교하는 엄격성 정도가 다름. (비교연산자는 느슨한, 일치비교연산자는 엄격한 비교를 한다.)
- loose equality : 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다. 타입이 다르더라도 암묵적 타입 변환후에 같은 값일 수 있다면 true반환.
- strict equality : 좌항과 우항의 피연사자가 타입도 같고 값도 같은 경우 true 반환, 암묵적타입변환을 하지 않음.
- strict equality에서 NaN을 주의해야함.  자신과 일치하지 않는 유일한값(NaN===NaN; //false)
- 빌트인 함수 Number.isNaN사용하여 숫자가 NaN인지 판단할 수 있다.
- Object.is메서드 : NaN일치문제, +0===-0 true문제의 경우 Object.is 메서드를 사용하여 예측 가능한 정확한 비교결과를 반환.

2. 대소 관계 비교 연산자 
- 피연산자의 크기를 비교하여 불리언 값을 반환, 부수효과 없다.

##### 삼항 조건 연산자 (ternary operator)
- 조건식의 평가 결과에 따라 반환할 값을 결정 , js 유일한 삼항 연산자, 부수효과 없다.
- 삼항 조건 연산자 표현식과 if-else의 차이점: 삼항 조건 연산자 표현식(값으로 평가할수 있는 표현식인 문)은 값처럼 사용 가능 if 불가능, if-else 표현식이 아닌 문. 


##### 논리연산자 (logical operator)

- 드 모르간의 법칙 

        !(x||y)===(!x&&!y)
        !(x&&y)===(!x||!y)

##### 쉼표연산자 
- 왼쪽 피연산자부터 차례대로 피연산자를 평가

##### 그룹연산자
- 소괄호로 감싸는 그룹연산자를 가장 먼저 평가 , 연산자 우선수위가 가장 높다. 

##### typeof 연산자
- 피연산자의 데이터타입을 문자열로 반환 
- null을 반환하는 경우는 없다 (object로 반환) ->null타입 확인할때 일치 연산자로 확인할것 
- typeof연산자가 반환하는 문자열은 7개의 데이터 타입과 정확하게 일치하지는 않는다.
- 선언하지 않은 식별자를 typeof 연산자로 연산해보면 undefined 반환

##### 지수 연산자
2**-2; //0.25
Math.pow(2,-2);//0.25
- 이항 연산자 중에서 우선순위가 가장 높다.

##### 그외 연산자
- ?. 옵셔널 체이닝 연산자
- ?? null 병합 연산자
- delete 프로퍼티 삭제 
- new 생성자 함수 호출할 때 사용하여 인스턴스를 생성
- instanceof 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별
- in 프로퍼티 존재 확인

##### 연산자의 부수효과 
- 부수효과가 있는 연산자 : 할당연산자, 증가/감소 연산자, delete 연산자 




