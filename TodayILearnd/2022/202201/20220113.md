#### 2022-01-13 To Do List

- 면접질문 리스트업
- 면접 발화 연습

#### 2022-01-13 Done List

- 면접질문 리스트업
- 면접 발화 연습

#### TIL

역시 현직자들에게 배울점은 너무 많다.
얼른 취직해서 멋진분들과 함께하고싶다.
근데 그러면서도 아직 너무 부족한 내가 얼마나 도움이 될까싶다..ㅠㅠ 열심히 공부해야지..

인상깊었던 면접 질문

1.  웹팩과 바벨

- 웹팩이란? 최신 프런트엔드 프레임워크에서 가장 많이 사용되는 '모듈번들러'이다.
- 모듈번들러란? 웹 애플리케이션을 구성하는 자원(html,css,javascript,lmages 등)을 모두 각각의 모듈로 보고 이를 조합해서 병합된 하나의 결과물을 만드는 도구를 의미한다.
- 모듈? 프로그래밍 관점에서 특정 기능을 갖는 작은 코드 단위를 의미 (성격이 비슷한 기능들을 하나의 의미있는 파일로 관리하면 모듈이 됨)
- 모듈 번들링? 웹 애플리케이션을 구성하는 몇십, 몇백개의 자원들을 하나의 파일로 병합 및 압축해주는 동작
  (빌드=번들링=변환 )
- 웹팩이 등장한 이유? 파일단위의 자바스크립트 모듈 관리의 필요성, 웹 개발 작업 자동화 도구(Grunt, Gulp), 웹애플리케이션의 빠른 로딩 속도와 높은 성능(레이지로딩의 등장)
- 웹팩으로 해결하려는 문제?
  자바스크립트의 변수 유효범위
  브라우저별 http요청 숫자의 제약(요청을 줄이는것이 성능을 높혀주고 사이트 조작시간을 앞당길수있음-> 웹팩으로 여러개의 파일을 하나로 합치면 요청횟수 줄일수있다.)
  사용하지 않는 코드의 관리, Dynamic Loading & Lazy Loading 미지원(코드 스필리팅 기능을 이용하여 원하는 모듈을 원하는 타이밍에 로딩 할 수 있음.)

- 바벨이란? 자바스크립트 컴파일러
- 자바스크립트는 인터프리터로 동작하는데 컴파일러 바벨을 사용하는이유?
  바벨이 고레벨 언어를 기계어로 번역하는 게 아닌, 자바스크립트로 결과물을 만들어주는 컴파일러이기 때문, 이런걸 소스 대 소스 컴파일러(transpiler)라고 부름.
- 인터프리터와 컴파일러의 차이 :
  컴파일러는 전체 소스를 파악하여 번역을 진행한다면 인터프리터는 소스코드의 각 행을 연속적으로 번역하여 실행한다.
  컴파일러는 전체를 한번 훑고 컴퓨터가 이해할 수 있는 기계어로 번역하는 반면, 인터프리터는 각행을 고레벨에서 중간 코드(intermediate code)로 즉각 변환&실행한다.
  중간 코드는 별도의 프로그램에 의해 읽혀서 실행되어진다.
  일반적으로는 컴파일러가 인터프리터보다는 실행이 빠르다.
  컴파일러는 전체를 파악하여 에러를 출력하지만 인터프리터는 오류가 발생한 시점에서 그 뒤는 번역하지 않는다.
  인터프리터 언어는 컴파일 언어보다 기계 종속성으로부터 자유롭다.
- 바벨의 사용이유 :
  바벨은 새로운 문법이나 타입스크립트 혹은 JSX 같이 다른 언어로 분류되는 언어들에 대해서도 모든 브라우저에서 동작할 수 있도록 호환성을 지켜줌.
  Babel 사용시 ES6, ES7 과 같은 최신 문법을 사용해서 코딩 후 브라우저 호환성을 위해 코드를 다시 작성할 필요가 없다.

- 바벨 동작 구분
  파싱 (parsing) : 코드를 읽고 추상 구문 트리(AST)로 변환하는 단계
  변환 (Transsforming) :
  추상 구문 트리를 변경하는 단계 ( 플러그인은 어떤 코드를 어떻게 변환할지에 대한 규칙을 정의, 플러그인들을 목적에 따라 묶어놓은 세트를 프리셋(preset)이라고 함.)
  출력 (Printing) : 변경된 결과물을 출력하는 단계

- 추상 구문 트리란? 프로그램 내에서 발생하는 기능을 나타내기 위해 만들어진 구문 구조, 이는 고수준의 언어를 기계어로 변환하는 과정에서 꼭 필요. 코드를 트리 구조의 데이터 스트럭쳐로 만들어냄.

출처
https://lihano.tistory.com/20
https://joshua1988.github.io/webpack-guide/webpack/what-is-webpack.html#%EB%AA%A8%EB%93%88%EC%9D%B4%EB%9E%80

2. 브라우저 파편화
   https://www.samsungsds.com/kr/insights/web_browser.html

3. usememo usecallback

- useMemo
  useMemo는 메모이즈된 값을 return하는 hook이다.
  useMemo는 이전 값을 기억해두었다가 조건에 따라 재활용하여 성능을 최적화 하는 용도로 사용된다.
  모든 함수를 useMemo로 감싸게 되면 이 또한 리소스 낭비가 될 수 있으므로,퍼포먼스 최적화가 필요한 연상량이 많은 곳에 사용하는 것이 좋다.
- useCallback
  useCallback은 리액트의 렌더링 성능을 위해서 제공되는 Hook이다.
  컴포넌트가 렌더링 될 때마다 내부적으로 사용된 함수가 새롭게 생성되는 경우,
  자식 컴포넌트에 Prop으로 새로 생성된 함수가 넘겨지게 되면 불필요한 리렌더링이 일어날 수 있다.
- useMemo는 함수의 연산량이 많을때 이전 결과값을 재사용하는 목적이고, useCallback은 함수가 재생성 되는것을 방지하기 위한 목적이다.

https://develogger.kro.kr/blog/LKHcoding/112

4. 프론트엔드에서 중요한점 3가지

https://blog.toss.im/article/toss-frontend-chapter

5. csr ssr 차이점

- SSR :Server Side Rendering 서버쪽에서 렌더링 준비를 끝마친 상태로 클라이언트에 전달하는 방식
- CSR Client Side Rendering 렌더링이 클라이언트 쪽에서 일어난다. 즉, 서버는 요청을 받으면 클라이언트에 HTML과 JS를 보내준다. 클라이언트는 그것을 받아 렌더링을 시작한다.
- 차이점

  - 첫 페이지 로딩시간.
    CSR의 경우 HTML, CSS와 모든 스크립트들을 한 번에 불러온다. 반면 SSR은 필요한 부분의 HTML과 스크립트만 불러오게 된다. 따라서 평균적으로 SSR이 더 빠르다.
  - 나머지 로딩 시간
    CSR은 이미 첫 페이지 로딩할 때 나머지 부분을 구성하는 코드를 받아왔기 때문에 빠름, SSR은 첫 페이지를 로딩한 과정을 정확하게 다시 실행한다. 그래서 더 느리다.

  - SEO 대응
    검색 엔진은 자동화된 로봇인 '크롤러'로 웹 사이트들을 읽는다. CSR은 자바스크립트를 실행시켜 동적으로 컨텐츠가 생성되기 때문에 자바스크립트가 실행 되어야 meatadata가 바뀌었다.
    (이전 크롤러들은 자바스크립트를 실행시키지 않았었기에 SEO 최적화가 필수적이었다. 구글이 그 트렌드를 바꾸고 있다고 한다.)
    SSR은 애초에 서버 사이드에서 컴파일되어 클라이언트로 넘어오기 때문에 크롤러에 대응하기 용이하다.

  - 서버 자원 사용
    SSR이 서버 자원을 더 많이 사용한다. 매번 서버에 요청을 하기 때문이다.

- 사용 권장 예시
  SSR
  네트워크가 느릴 때 (CSR은 한번에 모든 것을 불러오지만 SSR은 각 페이지마다 나눠불러오기 때문)
  SEO(serach engine optimization : 검색 엔진 최적화)가 필요할 때.
  최초 로딩이 빨라야하는 사이트를 개발 할 때
  메인 스크립트가 크고 로딩이 매우 느릴 때CSR은 메인스크립트가 로딩이 끝나면 API로 데이터 요청을 보낸다. 하지만 SSR은 한번의 요청에 아예 렌더가 가능한 페이지가 돌아온다.
  웹 사이트가 상호작용이 별로 없을 때.

  CSR
  네트워크가 빠를 때
  서버의 성능이 좋지 않을 때
  사용자에게 보여줘야 하는 데이터의 양이 많을 때.(로딩창을 띄울 수 있는 장점이 있다.)
  메인 스크립트가 가벼울 때
  웹 어플리케이션에 사용자와 상호작용할 것들이 많을 때. (아예 렌더링 되지 않아서 사용자의 행동을 막는 것이 경험에 오히려 유리함.)

https://proglish.tistory.com/216

6. 어떤 개발자가 되고싶은지

7. 협업에서 중요한점

8. 스택오버플로어가 뭐냐

- Stack Overflow는 Stack 영역의 메모리가 지정된 범위를 넘어갈 때 발생한다.
- Stack 메모리는 보통 지역 변수가 저장되는 영역이다.함수에서 지역 변수를 선언하면 지역 변수는 Stack 메모리에 할당되고 함수를 빠져나오면 Stack 메모리에서 해제된다.
  하나의 프로그램이 실행될 때 수많은 함수를 호출하고 빠져 나오게 되는데 그 때마다 함수에서 사용하는 지역 변수는 Stack 영역에 할당되고 해제되는 것을 반복하게 되며 그에 따라 사용하는 Stack 영역도 변하게 된다.
  만약 한 함수에서 너무 큰 지역 변수를 선언하거나 함수를 재귀적으로 무한정 호출하게 되면 stack overflow가 발생할 수 있다.
  stack overflow가 발생하면 컴파일러 옵션에서 stack 영역의 크기를 늘리거나 또는 함수에서 사용하는 지역 변수의 크기를 줄이거나 아니면 지역 변수를 전역 변수로 바꾸어 해결할 수 있다.
  Visual C++과 같은 PC 컴파일러에서는 디버깅 모드에서 Stack Overflow가 발생하면 Stack Overflow 에러 메세지를 출력하지만 임베디드 시스템에서는 Stack Overflow 에러 메세지를 출력하지 않고 이상 동작하는 경우가 많기 때문에 주의해야 한다.

9. 자바스크립트 바디에 첨부하는 이유

10. 로컬스토리지와 세션, 쿠키의 차이점

11. window.requestAnimationFrame 이란

https://guiyomi.tistory.com/100

12. cors 에러란

https://ghost4551.tistory.com/46

#### 2022-01-14 To Do List

- 1차 과제 수행 (전체 레이아웃과 로그인 및 cr까지 구현 )
- 면접 스터디
